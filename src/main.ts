import * as tf from "@tensorflow/tfjs";
import "./style.css";
import {
  Graph,
  addInverseRelation,
  graphFromPredicates,
  randomForestGraph,
} from "./graph.ts";
import { default as cytoscape } from "cytoscape";
import {
  graphToTFJSData,
  trainTestSplit,
  trainModel,
  makeMLPPredicateModel,
  N_EPOCHS,
  computeCorrectProbs,
} from "./model.ts";
import {
  addTrainTest,
  addProbabilities,
  drawGraph,
  redrawGraph,
} from "./visualization.ts";
import { default as ProgressBar } from "progressbar.js";
import Line from "progressbar.js/line";

var graph: Graph | undefined;

function graphFromFreeformInput(): Graph {
  const graphText: string = document
    .querySelector<HTMLTextAreaElement>("#freeform-graph")!
    .value.trim();
  const lines = graphText.split("\n").map((text) => text.trim());
  return graphFromPredicates(...lines);
}

function parseChildDistribution(distributionText: string): Map<number, number> {
  const distribution = new Map<number, number>();

  try {
    const obj = JSON.parse(
      distributionText.replace(/(\d+(?:\.\d+)?)/g, '"$1"'),
    );

    for (const [key, value] of Object.entries(obj)) {
      const probability = parseFloat(key);
      const childCount = Number(value);

      if (isNaN(probability) || isNaN(childCount)) {
        throw new Error("Invalid input format");
      }

      distribution.set(probability, childCount);
    }
  } catch (error) {
    console.error("Error parsing distribution:", error);
    return new Map();
  }

  return distribution;
}

function updateFreeformDisplay() {
  const useFreeformInput: boolean = document.querySelector<HTMLInputElement>(
    "#use-freeform-input",
  )!.checked;

  function setDisplay(element: HTMLElement, value: boolean) {
    element.style.display = value ? "" : "none";
  }

  setDisplay(document.querySelector("#freeform-graph")!, useFreeformInput);
  setDisplay(document.querySelector("#auto-generate")!, !useFreeformInput);
}

function autoGeneratedGraph(): Graph {
  const numTrees: number = parseInt(
    document.querySelector<HTMLInputElement>("#num-trees")!.value,
  );

  const maxDepth: number = parseInt(
    document.querySelector<HTMLInputElement>("#max-depth")!.value,
  );

  console.log({
    numTrees,
    maxDepth,
  });

  const childDistribution: Map<number, number> = parseChildDistribution(
    document.querySelector<HTMLInputElement>("#child-distribution")!.value,
  );

  return randomForestGraph(
    new Map([[1, numTrees]]),
    childDistribution,
    "<",
    maxDepth,
  );
}

function parseGraph(): Graph {
  const useFreeformInput: boolean = document.querySelector<HTMLInputElement>(
    "#use-freeform-input",
  )!.checked;
  const graph: Graph = useFreeformInput
    ? graphFromFreeformInput()
    : autoGeneratedGraph();

  const shouldAddInverseRelations: boolean =
    document.querySelector<HTMLInputElement>("#inverse-relations")!.checked;

  if (shouldAddInverseRelations) {
    // TODO: this just takes the first relation and inverts it
    // that should be controllable by the user
    const relationToInvert: string = Array.from(graph.relationTypes())[0];
    const invertedRelation: string = relationToInvert == ">" ? "<" : ">";
    addInverseRelation(graph, relationToInvert, invertedRelation);
  }

  return graph;
}

function ParseMLPModel(graph: Graph): tf.LayersModel {
  return makeMLPPredicateModel(
    graph.relationTypes().size,
    graph.nodes.size,
    parseInt(document.querySelector<HTMLInputElement>("#hidden-size")!.value),
    parseInt(document.querySelector<HTMLInputElement>("#n-layers")!.value),
    parseFloat(
      document.querySelector<HTMLInputElement>("#l2-regularization")!.value,
    ),
    parseFloat(document.querySelector<HTMLInputElement>("#dropout")!.value),
  );
}

document.addEventListener("DOMContentLoaded", function () {
  document.querySelector<HTMLTextAreaElement>("#freeform-graph")!.value = `1 < 2
2 < 3 
4 < 5
5 < 6
7 < 8
`;
  updateFreeformDisplay();
  graph = parseGraph();
  const cy: cytoscape.Core = drawGraph(
    document.getElementById("vis-container")!,
    graph,
  );

  document
    .querySelector<HTMLInputElement>("#use-freeform-input")
    ?.addEventListener("change", updateFreeformDisplay);

  const bar: Line = new ProgressBar.Line("#bar-container", {
    strokeWidth: 2,
    easing: "easeInOut",
    duration: 1,
    color: "#4caf50",
    trailColor: "#eee",
    trailWidth: 1,
    svgStyle: { width: "100%", height: "5px" },
  });

  document
    .querySelector<HTMLButtonElement>("#redraw")!
    .addEventListener("click", () => {
      graph = parseGraph();
      redrawGraph(cy, graph);
    });

  document
    .querySelector<HTMLButtonElement>("#submit")
    ?.addEventListener("click", () => {
      bar.animate(1.0);
      const model: tf.LayersModel = ParseMLPModel(graph!);
      const split: number = 0.7;
      const dataset = graphToTFJSData(graph!);
      trainTestSplit(dataset, split).then((splitDataset) => {
        addTrainTest(cy, splitDataset.split_idxs);
        trainModel(model, splitDataset, (epoch) => {
          bar.animate((epoch + 1) / N_EPOCHS);
        }).then(() => {
          computeCorrectProbs(model, dataset).then((probs) => {
            console.log({ probs });
            addProbabilities(cy, probs);
          });
        });
      });
    });
});

console.log("Created vis?");

const g = new Graph();
console.log(g.toString());
